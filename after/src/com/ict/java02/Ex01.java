package com.ict.java02;

public class Ex01 {
	/*
	Ex 1. 클래스는 무엇들로 이루어 졌는가 (3가지 쓰시오) ?
	  답) 멤버핃드, 생성자, 멤버메소드
	
	- 멤버필드(변수와 상수) : 데이터
	  변수 : 언제든지 변할 수 있는 데이터 (값)
	  상수 : 한번 저장되면 변경할 수 없는 데이터 (값)
		예) private String name, hak;
			private int kor, eng, math, sum;
			private double avg;
	
	- 생성자 : 클래스를 객체로 만들 때 반드시 호출해야 되는 것.
		  생성자의 목적 : 멤버필드의 초기값을 지정하는 것이 목적.
		  생성자의 구조 : 1) 클래스와 같은 이름을 쓴다.
		    			  2) 반환형이 없는 메소드와 같다.
		  -> 한 클래스에서 생성자를 여러개 가질 수 있다. (생성자 오버로드)
		  -> 인자가 없는 생성자를 기본 생성자라고 한다.
		  -> 만약에 생성자를 만들지 않으면 해당 클래스를 객체로 만들 때 기본 생성자를 사용해야 한다.
		  -> 그런데 생성자가 존재하면 존재하는 생성자로 만들어야 한다.
		  -> 생성자를 객체로 만드는 방법 
		  	 클래스 이름 참조변수 = new  생성자();
	  	 
	 - 멤버메소드 : 기능, 동작, 하는 것, 작동
	 	  -> 메소드를 호출하면 어떠한 내용을 실행한다.(동작한다.)
	 	  -> 한 클래스에서 같은 이름의 여러 메소드를 오버로드라고 한다.
	 	  -> 반환형 : 어떠한 행동을 한 후 반드시 자기를 호출한 곳으로 되돌아 간다.
	 				  내용을 가지고 가면 반환형이 있다. 그 내용의 자료형을 반환형이라 부른다.
					  만약에 내용을 가지고 가지 않으면 반환형이 없는 것이다.
				      이렇게 반환형이 없으면 void라고 쓴다.
		  -> getter() : 메소드를 호출한 곳에서 무언가를 얻어 낼 때 사용하는 메소드
		  -> setter() : 메소드를 이용하여 멤버 변수의 값(데이터)을 변결 할 때 사용
		  
		  
		  
	Ex 2. 클래스를 객체로 생성할 때 초기화 목적으로 반드시 호출하는 것은 무엇인가?
	  답) 생성자 
	  	  생성자의 특징 : 클래스와 이름이 같다.
	  	  				  반환형이 없는 메소드와 같다.
	  	  				  
	  	  				  
	 
 	Ex 3. 어떤 클래스에서 같은 이름의 여러개 존재하는 것으로 반드시 매게 변수는 달라야 하는 것을 무엇이라 하는가?
 	  답) 오버로드(오버로딩)
 	  
 	  - 이름이 같은데 오류가 나지 않는 이유 : 인자의 종류나 인자의 갯수, 자료형이 틀리면 이름이 같아도 오류가 나지 않는다.
 	  
 	  
 	  
  	Ex 4. 상속관계에서 부모클래스의 메소드를 자식클래스가 가져와서 자식클래스 상황에 맞게 변경하는 것을 무엇이라 하는가?
  	      상속 : 클래스와 클래스의 관계를 말하는데 부모클래스(super)가 만들어지고 자식 클래스(sub)가 만들어진다.
  	       		 자식클래스가 부모클래스의 모든 멤버필드, 멤버메소드 객체 생성 없이 마음대로 사용할 수 있도록 관계를 맺는 것을 말한다.
  	       		 
  	  답) 오버라이드(오버라이딩)
  	  
  	  오버라이딩 : 자식클래스가 부모클래스의 메소드를 가지고 와서 변경해서 쓴다.
  	  final클래스 : 상속을 못하게 한다. (자식클래스 못 만든다.) 
  	  final메소드 : 오버라이드를 못하게 한다. 
  	  final변수 : 상수 (데이터 변경을 못하게 안된다.)
  	  
  	  
  	
  	Ex 5. 추상클래스와 인터페이스에 대해서 쓰시오.
  		- 추상클래스 : 추상메소드를 하나 이상 가지고 있는 클래스.
  		  추상메소드 : 메소드의 내용(몸체=body)가 존재하지 않는 메소드.
  		  일반메소드 : public 반환형 이름([인자]) { 실행내용 };
  		  추상메소드 : public 반환형 이름([인자]);
  		  
  		* 추상메소드나 추상클래스 이면 무조건 abstract 예약어를 사용해야 된다.
  		* 예) public abstract class Unit { 추상클래스 // 추상메소드 public abstract void decEnergy();}
  		* 추상클래스를 상속받은 일반클래스는 무조건 추상메소드를 오버라이딩해야 한다.
  		  예) public class Protoss extends Unit {
  		  		@Override
  		  		public abstract void decEnergy() {
  		  		}
  		  	}
  		  	
  		- 인터페이스 : 상수와 추상메소드로만 이루어졌다.
  		  	 		   객체 생성 할 수 없다. 
  		  			   interface 예약어를 사용한다.
  		  
  		  public interface Ex01 {
  		  	상수와 추상메소드
  		  	// 추상 메소드
  		  	public abstract void play();
  		  	// interface 에서는 abstract 예약어를 사용하지 않아도 오류가 아니다.
  		  	 public void sound(); 
  		  	}
  		  	
  		  	** 인터페이스를 상속 받은 일반 클래스는 무조건 추상 메소드를 오버라이드 해야된다. 
 	  		
 	  		public Ex02 implements Ex01 {
 	  			@Override
 	  		 	public abstract void play() {
 	  		 	
 	  		 	}
 	  		 	
 	  		 	@Override
 	  		 	public void sound() {
 	  		 	
 	  		 	}
 	  		}
 	  
 	
		  
	
	*/
	
}
